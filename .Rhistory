do.geographic.label <- function(data_base, col_sp,  col_lon, col_lat, gazzeters = F, outliers = F,
test_gazz = c("capitals", "centroids", "equal", "gbif", "institutions",
"seas", "gbif", "zeros", "duplicates"),
test_ouliers = c("distance", "quantile", "mad"),
outliers_details = c(1000, 5, 5), thinning_res = 0.0833, mergeto_db = F){
if(!require(CoordinateCleaner)) install.packages("CoordinateCleaner")
if(gazzeters == T){
gazz_results <- CoordinateCleaner::clean_coordinates(
x = data_base,
lon = col_lon,
lat = col_lat,
species = col_sp,
tests = test_gazz,
capitals_rad = 10000,
centroids_rad = 1000,
centroids_detail = "both",
inst_rad = 100,
range_rad = 1000,
country_refcol = "iso_a3",
value = "spatialvalid",
verbose = FALSE,
report = FALSE
)
gazz_results <- gazz_results[, (ncol(gazz_results)-length(test_gazz)):ncol(gazz_results)]
gazz_results <- ((!gazz_results)*1) |> as.data.table()
}
if(outliers == T){
outl_list <- list()
for(i in 1:length(test_ouliers)){
if(test_ouliers[i] == "distance") tdi = outliers_details[1]
if(test_ouliers[i] == "quantile") mltpl = outliers_details[2]
if(test_ouliers[i] ==  "mad") mltpl = outliers_details[3]
outl_i <- cc_outl(
x = data_base,
lon = col_lon,
lat = col_lat,
species = col_sp,
method = test_ouliers[i],
tdi = tdi,
mltpl = 5,
value = "flagged",
sampling_thresh = 0,
min_occs = 7,
thinning = T,
thinning_res = thinning_res,
verbose = F
) |> as.data.table()
outl_list[[i]] <- outl_i
}
outliers_results <- do.call(cbind, outl_list)
colnames(outliers_results) <- paste0("geo.", test_ouliers)
outliers_results <- ((!outliers_results)*1) |> as.data.table()
}
if(exists("gazz_results") & !exists("outliers_results")){
results <- gazz_results
}else if(!exists("gazz_results") & exists("outliers_results")){
results <- outliers_results
}else if(exists("gazz_results") & exists("outliers_results")){
results <- cbind(gazz_results, outliers_results)
}
return(results)
}
a_geo <- do.geographic.label(data_base = a, col_sp = "acceptedNameUsage", col_lon = "lon", col_lat = "lat",
gazzeters = F, outliers = T)
a <- cbind(a, a_geo);rm(a_geo)
View(a)
load("registros_demo/subset16.RData")
a <- subset16[acceptedNameUsage == "Acacia decurrens"]
rm(subset16);gc()
a_geo <- do.geographic.label(data_base = a, col_sp = "acceptedNameUsage", col_lon = "lon", col_lat = "lat",
gazzeters = F, outliers = T)
a <- cbind(a, a_geo);rm(a_geo)
library(terra)
envars <- rast("envars/")
envars <- list.files("envars/", "*.tif$")
envars <- list.files("envars/", ".tif")
envars <- list.files("envars/", ".tif") |> rast()
envars <- list.files("envars/", ".tif", full.names = T) |> rast()
plot(envars)
View(a)
do.corr.envars <- function(envars = envars, sample_size = 10000){
if(!require(terra)) install.packages("terra")
sample_env <- terra::spatSample(envars, size = 10000, method = "random", replace = F, na.rm = T,
as.points= T)
}
do.corr.envars <- function(envars = envars, sample_size = 10000){
if(!require(terra)) install.packages("terra")
sample_envars <- terra::spatSample(envars, size = 10000, method = "random", replace = F, na.rm = T,
as.points= F, )
}
do.corr.envars <- function(envars = envars, sample_size = 10000){
if(!require(terra)) install.packages("terra")
sample_envars <- terra::spatSample(envars, size = 10000, method = "random", replace = F, na.rm = T,
as.df= T, )
}
a <- do.corr.envars()
do.corr.envars <- function(envars = envars, sample_size = 10000){
if(!require(terra)) install.packages("terra")
sample_envars <- terra::spatSample(envars, size = 10000, method = "random", replace = F, na.rm = T,
as.df= T)
}
c <- do.corr.envars()
sample_envars <- terra::spatSample(envars, size = 10000, method = "random", replace = F, na.rm = T,
as.df= T)
View(sample_envars)
do.corr.envars <- function(envars = envars, sample_size = 10000){
if(!require(terra)) install.packages("terra")
sample_envars <- terra::spatSample(envars, size = 10000, method = "random", replace = F, na.rm = T,
as.df= T)
}
c <- do.corr.envars()
c <- do.corr.envars(envars = envars)
View(c)
rm(sample_envars)
c <- do.corr.envars(envars = envars) |> cor()
c
do.corr.envars <- function(envars = envars, sample_size = 10000){
if(!require(terra)) install.packages("terra")
sample_envars <- terra::spatSample(envars, size = 10000, method = "random", replace = F, na.rm = T,
as.df= T)
correlacion <- sample_envars |> cor()
}
do.corr.envars()
do.corr.envars(envars = envars)
do.corr.envars <- function(envars = envars, sample_size = 10000){
if(!require(terra)) install.packages("terra")
sample_envars <- terra::spatSample(envars, size = 10000, method = "random", replace = F, na.rm = T,
as.df= T)
correlacion <- sample_envars |> cor()
return(correlacion)
}
do.corr.envars(envars = envars)
#
envars <- list.files("envars/", ".tif", full.names = T) |> rast()
envars
#
envars <- list.files("envars/", ".tif", full.names = T) |> rast()
do.corr.envars(envars = envars)
rm(c)
rm(F)
# aplicación piloto:
source("R/funciones_limpieza.R")
# Cargar funciones de los modulos
source("R/funciones_limpieza.R")
library(data.table)
library(sf)
library(terra)
envars <- list.files("envars/", ".tif", full.names = T) |> rast()
do.corr.envars(envars = envars)
# 1. cargar registros
load("registros_demo/subset16.RData")
spx <- subset16[acceptedNameUsage == "Acacia decurrens"]
rm(subset16);gc()
# 2. aplicar modulo geografico: gazzeter y outliers (geograficos)
spx_geo <- do.geographic.label(data_base = a, col_sp = "acceptedNameUsage", col_lon = "lon", col_lat = "lat",
gazzeters = F, outliers = T)
# 2. aplicar modulo geografico: gazzeter y outliers (geograficos)
spx_geo <- do.geographic.label(data_base = spx, col_sp = "acceptedNameUsage", col_lon = "lon", col_lat = "lat",
gazzeters = F, outliers = T)
View(envars)
IQR(x)
# Cargar funciones de los modulos
source("R/funciones_limpieza.R")
library(data.table)
library(sf)
library(terra)
envars <- list.files("envars/", ".tif", full.names = T) |> rast()
# 1. cargar registros
load("registros/subset16.RData")
spx <- subset16[acceptedNameUsage == "Acacia decurrens"]
rm(subset16);gc()
env = envars
data_base = spx
col_lon = "lon"
col_lat = "lat"
univar = T
multivar = F
test_multivar = c("pca_error", "maha")
multivar_details = c("maha_pval" = 0.05)
env_space <- gen.env.space(env. = env, data.base = data_base, col.lon = col_lon, col.lat = col_lat)
out_multivar <- data.frame(matrix(NA, nrow = nrow(data_base), ncol = length(test_multivar)))
colnames(out_multivar) <- test_multivar
# hallar los datos perdidos, no pueden ser trabajados en los test multivariados
xNA <- apply(X = env_space, 2, FUN = function(X){which(is.na(X))}) |> unlist() |> unique()
# media y escalar las variables
mu <-  colMeans(env_space[-xNA, ])
env_space_scale <-  scale(env_space[-xNA, ], center = mu, scale = T)
#calcular PCA
Xpca <- prcomp(x = env_space_scale)
if(!require(ClassDiscovery)) install.packages("ClassDiscovery")
if(!require(ClassDiscovery)) install.packages("ClassDiscovery")
maha2 <- mahalanobisQC(Xpca, 2)
Xpca <- SamplePCA(data = env_space_scale)
View(Xpca)
#establecer la varianza compuesta de los componentes
summary_pca <- summary(Xpca)
Xpca@scores
Xpca@variances
Xpca@components
Xpca@splitter
Xpca@usecor
Xpca@
#calcular PCA
Xpca <- prcomp(x = env_space_scale)
Xpca@shift
Xpca@scale
Xpca@call
Xpca <- SamplePCA(data = env_space_scale, center = F, usecor = F)
Xpca <- SamplePCA(data = env_space_scale, center = F, usecor = F)
Xpca@variances
# media y escalar las variables
mu <-  colMeans(env_space[-xNA, ])
env_space_scale <-  scale(env_space[-xNA, ], center = mu, scale = T)
spca <- SamplePCA(env_space_scale)
round(cumsum(spca@variances)/sum(spca@variances), digits=2)
spca <- SamplePCA(env_space_scale, usecor = F, center = F)
round(cumsum(spca@variances)/sum(spca@variances), digits=2)
spca@scores
#calcular PCA
Xpca <- prcomp(x = env_space_scale)
spca@call
spca@scale
spca@shift
spca@usecor
spca@components
#calcular PCA
Xpca <- prcomp(x = env_space_scale)
Xhat <-  Xpca$x
View(Xhat)
Xpca$x
spca@components
ound(cumsum(spca@variances)/sum(spca@variances), digits=2)
maha2 <- mahalanobisQC(spca, 2)
myd <- data.frame(maha2)
View(myd)
View(myd)
spca <- SamplePCA(env_space_scale, usecor = F, center = F)
spca <- SamplePCA(env_space_scale, usecor = F, center = F)
spca <- SamplePCA(env_space_scale)
maha2 <- mahalanobisQC(spca, 2)
myd <- data.frame(maha2)
View(myd)
spca <- SamplePCA(env_space[-xNA])
maha2 <- mahalanobisQC(spca, 2)
env_space
spca <- SamplePCA(env_space_scale)
spca <- SamplePCA(env_space_scale, usecor = F, center = F)
maha2 <- mahalanobisQC(spca, 5)
myd <- data.frame(maha2)
View(maha2)
set.seed(564684)
nSamples <- 30
nGenes <- 3000
dataset <- matrix(rnorm(nSamples*nGenes), ncol=nSamples, nrow=nGenes)
dimnames(dataset) <- list(paste("G", 1:nGenes, sep=''),
+ paste("S", 1:nSamples, sep=''))
View(dataset)
nShift <- 300
affected <- sample(nGenes, nShift)
dataset[affected,1] <- dataset[affected,1] + rnorm(nShift, 1, 1)
dataset[affected,2] <- dataset[affected,2] + rnorm(nShift, 1, 1)
View(dataset)
spca <- SamplePCA(dataset)
round(cumsum(spca@variances)/sum(spca@variances), digits=2)
maha2 <- mahalanobisQC(spca, 2)
maha5 <- mahalanobisQC(spca, 5)
maha10 <- mahalanobisQC(spca, 10)
maha20 <- mahalanobisQC(spca, 20)
myd <- data.frame(maha2, maha5, maha10, maha20)
colnames(myd) <- paste("N", rep(c(2, 5, 10, 20), each=2), rep(c(".statistic", ".p.value"), 4), sep='')
View(myd)
spca <- SamplePCA(env_space_scale, usecor = F, center = F)
spca_t <- t(spca)
spca <- SamplePCA(t(env_space_scale), usecor = F, center = F)
spca
t(env_space_scale)
a <- t(env_space_scale)
View(a)
spca <- SamplePCA(a, usecor = F, center = F)
round(cumsum(spca@variances)/sum(spca@variances), digits=2)
spca@components
maha2 <- mahalanobisQC(spca, 2)
View(maha2)
env_space_scale_t <- t(env_space_scale)
View(maha2)
maha2 <- mahalanobisQC(spca, 4)
View(maha2)
prop <- round(cumsum(spca@variances)/sum(spca@variances), digits=2)
"pval" = 0.95
multivar_details = c("pval" = 0.95)
which(prop >= multivar_details["pval"])[1]
colnames(myd) <- paste("N", c(".statistic", ".p.value"), sep='')
env_space_scale_t <- t(env_space_scale)
spca <- SamplePCA(env_space_scale_t, usecor = F, center = F)
prop <- round(cumsum(spca@variances)/sum(spca@variances), digits=2)
nComp <- which(prop >= multivar_details["pval"])[1]
maha <- mahalanobisQC(spca, ncomp)
myd <- data.frame(maha)
colnames(myd) <- paste("N", c(".statistic", ".p.value"), sep='')
env_space_scale_t <- t(env_space_scale)
spca <- SamplePCA(env_space_scale_t, usecor = F, center = F)
prop <- round(cumsum(spca@variances)/sum(spca@variances), digits=2)
nComp <- which(prop >= multivar_details["pval"])[1]
maha <- mahalanobisQC(spca, ncomp)
maha <- mahalanobisQC(spca, nComp)
myd <- data.frame(maha)
View(myd)
View(myd)
View(out_multivar)
View(myd)
multivar_details["pval"]-1
(1- multivar_details["pval"])
pvalue <= (1- multivar_details["pval"])
myd$p.value <= (1- multivar_details["pval"])
myd$p.value <- myd$p.value <= (1- multivar_details["pval"])*1
View(myd)
myd$p.value <- (myd$p.value <= (1- multivar_details["pval"]))*1
View(myd)
myd <- data.frame(maha)
View(myd)
myd$p.value <- (myd$p.value <= (1- multivar_details["pval"]))*1
View(myd)
View(maha2)
maha <- mahalanobisQC(spca, nComp)
myd <- data.frame(maha)
myd$p.value <- (myd$p.value <= (1- multivar_details["pval"]))*1
View(myd)
colnames(maha) <- c("dist.maha", paste0("p.val.",(1- multivar_details["pval"])))
View(maha)
env_space_scale_t <- t(env_space_scale)
spca <- SamplePCA(env_space_scale_t, usecor = F, center = F)
prop <- round(cumsum(spca@variances)/sum(spca@variances), digits=2)
nComp <- which(prop >= multivar_details["pval"])[1]
maha <- mahalanobisQC(spca, nComp)
maha <- data.frame(maha)
maha <- mahalanobisQC(spca, nComp)
mahad$p.value <- (mahad$p.value <= (1- multivar_details["pval"]))*1
maha$p.value <- (mahad$p.value <= (1- multivar_details["pval"]))*1
maha$p.value <- (maha$p.value <= (1- multivar_details["pval"]))*1
colnames(maha) <- c("dist.maha", paste0("p.",(1- multivar_details["pval"])))
View(maha)
class(maha)
insertRow <- function(existingDF, newrow, r) {
existingDF[seq(r+1,nrow(existingDF)+1),] <- existingDF[seq(r,nrow(existingDF)),]
existingDF[r,] <- newrow
existingDF
}
maha <- insertRow(existingDF = maha, newrow = rep(NA, ncol(maha), r = xNA-1))
ncol(maha)
maha <- insertRow(existingDF = maha, newrow = rep(NA, ncol(maha)), r = xNA-1)
colnames(maha) <- c("dist.maha", "p.value")
View(maha)
out_multivar$maha <- maha$dist.maha
out_multivar$pvalue <- maha$p.value
View(out_multivar)
# B.2 etiquetado ambiental
do.environmental.label <- function(
env = envars, data_base, col_lon, col_lat, univar = F, multivar = F,
test_univar = c("zscore", "std", "iqr", "rjack" ), test_multivar = c("pca_error", "maha"),
univar_details = c("thr_std" = 4, "mtpl_iqr" = 1.5), multivar_details = c("pval" = 0.95),
min_occs = 7
){
env_space <- gen.env.space(env. = env, data.base = data_base, col.lon = col_lon, col.lat = col_lat)
if(univar == T){
# inicializar output
out_univar <- data.frame(matrix(NA, nrow = nrow(data_base),
ncol = length(test_univar)*ncol(env_space)))
out_names <- apply(expand.grid( colnames(env_space), test_univar), 1, paste, collapse=".")
colnames(out_univar) <- out_names
if(nrow(data_base) <=  min_occs){
return(out_univar)
}else{
for(i in 1:ncol(env_space)){
x <-  env_space[, ..i] |> as.matrix() |> as.vector()
xi <- na.omit(x)
xNA <- which(is.na(x) == T)
for(a in 1:length(test_univar)){
test_a <- test_univar[a]
if(test_a == "zscore") out_ <- zscore(x = xi )
if(test_a == "std") out_ <- std(x = xi , threshold = univar_details["thr_std"])*1
if(test_a == "iqr") out_ <- iqr(x = xi, mtp = univar_details["mtpl_iqr"])*1
if (test_a == "rjack") out_ <- rjack(x = xi )
name.test <- paste0(colnames(env_space)[i], ".", test_a)
if(length(xNA)!= 0){
out_ <- append(x = out_, values = rep(NA, length(xNA)), after = xNA-1 )
}
out_univar[, name.test] <- out_
}
}
}
univar_results <- out_univar |> data.table()
}
if(multivar == T){
out_multivar <- data.frame(matrix(NA, nrow = nrow(data_base), ncol = length(test_multivar)))
colnames(out_multivar) <- test_multivar
# hallar los datos perdidos, no pueden ser trabajados en los test multivariados
xNA <- apply(X = env_space, 2, FUN = function(X){which(is.na(X))}) |> unlist() |> unique()
# media y escalar las variables
mu <-  colMeans(env_space[-xNA, ])
env_space_scale <-  scale(env_space[-xNA, ], center = mu, scale = T)
if("pca_error" %in% test_multivar){
#calcular PCA
Xpca <- prcomp(x = env_space_scale)
#establecer la varianza compuesta de los componentes
summary_pca <- summary(Xpca)
prop <- (summary_pca$sdev^2 / sum(summary_pca$sdev^2)) |> cumsum()
#elegir aquellos en donde se complete el x porcentaje de varianza a trabajar
nComp <- which(prop >= multivar_details["pval"])[1]
# recrear el dataset escalado y establecer la diferencia entre el original y el predicho
Xhat <-  Xpca$x[,1:nComp] %*% t(Xpca$rotation[,1:nComp])
errorq_pca <- (env_space_scale - Xhat)^2
# el resto de errores por cada variable estan correlacionados al 100% por lo que el
# error de pca en una variable predicha nos habla de todas las otras
errorq_pca <- errorq_pca[,1]
# agregar aquellos registros con datos perdidos
errorq_pca <- append(x = errorq_pca, values = rep(NA, length(xNA)), after = xNA-1 )
out_multivar[, "pca_error"] <- errorq_pca
}
if("maha" %in% test_multivar){
if(!require(ClassDiscovery)) install.packages("ClassDiscovery")
# transponer la matriz ambiental
env_space_scale_t <- t(env_space_scale)
# generar un objeto pca sample, ya se escalaron los datos y se centraron
spca <- SamplePCA(env_space_scale_t, usecor = F, center = F)
# establecer la proporción acumulada explicada por los componentes y elegir
# aquel en donde se da el valor de probabilidad deseado
prop <- round(cumsum(spca@variances)/sum(spca@variances), digits=2)
nComp <- which(prop >= multivar_details["pval"])[1]
#MISSING: armonizar los metodos de PCA usados
# establecer la distancia de mahalanobis y hallar valores de probabilidad
maha <- mahalanobisQC(spca, nComp)
# binarizar los valores de probabilidad, marcando los que esten por debajo
# de significatividad estadistica deseada 1 - pvalor
maha$p.value <- (maha$p.value <= (1- multivar_details["pval"]))*1
colnames(maha) <- c("dist.maha", "p.value")
# agregar valores NA
maha <- insertRow(existingDF = maha, newrow = rep(NA, ncol(maha)), r = xNA-1)
# adjuntar a la data.frame de salida
out_multivar$maha <- maha$dist.maha
out_multivar$p.value <- maha$p.value
}
multivar_results <- out_multivar|> data.table()
}
# compilar resultados segun la categoria de test desarollado
if(exists("univar_results") & !exists("multivar_results")){
results <- univar_results
}else if(!exists("univar_results") & exists("multivar_results")){
results <- multivar_results
}else if(exists("univar_results") & exists("multivar_results")){
results <- cbind(univar_results, multivar_results)
}
return(results)
}
# Cargar funciones de los modulos
source("R/funciones_limpieza.R")
library(data.table)
library(sf)
library(terra)
envars <- list.files("envars/", ".tif", full.names = T) |> rast()
# 1. cargar registros
load("registros/subset16.RData")
spx <- subset16[acceptedNameUsage == "Acacia decurrens"]
rm(subset16);gc()
# 2. aplicar modulo geografico: gazzeter y outliers
spx_geo <- do.geographic.label(data_base = spx, col_sp = "acceptedNameUsage", col_lon = "lon",
col_lat = "lat", gazzeters = T, outliers = T)
# 3. aplicar modulo ambiental: univariado y multivariado
spx_amb <- do.environmental.label(env = envars, data_base = spx, col_lon = "lon", col_lat = "lat",
univar = T, multivar = F)
View(spx_amb)
# 3. aplicar modulo ambiental: univariado y multivariado
spx_amb <- do.environmental.label(env = envars, data_base = spx, col_lon = "lon", col_lat = "lat",
univar = F, multivar = T)
View(spx_amb)
# Cargar funciones de los modulos
source("R/funciones_limpieza.R")
# 3. aplicar modulo ambiental: univariado y multivariado
spx_amb <- do.environmental.label(env = envars, data_base = spx, col_lon = "lon", col_lat = "lat",
univar = F, multivar = T)
View(spx_amb)
# 3. aplicar modulo ambiental: univariado y multivariado
spx_amb <- do.environmental.label(env = envars, data_base = spx, col_lon = "lon", col_lat = "lat",
univar = T, multivar = T)
View(spx_amb)
insertRow <- function(existingDF, newrow, r) {
existingDF[seq(r,nrow(existingDF)),] <- existingDF[seq(r,nrow(existingDF)),]
existingDF[r,] <- newrow
existingDF
}
# Cargar funciones de los modulos
source("R/funciones_limpieza.R")
# 3. aplicar modulo ambiental: univariado y multivariado
spx_amb <- do.environmental.label(env = envars, data_base = spx, col_lon = "lon", col_lat = "lat",
univar = T, multivar = T)
insertRow <- function(existingDF, newrow, r) {
existingDF[seq(r,nrow(existingDF)+1),] <- existingDF[seq(r,nrow(existingDF)),]
existingDF[r,] <- newrow
existingDF
}
# 3. aplicar modulo ambiental: univariado y multivariado
spx_amb <- do.environmental.label(env = envars, data_base = spx, col_lon = "lon", col_lat = "lat",
univar = T, multivar = T)
# Cargar funciones de los modulos
source("R/funciones_limpieza.R")
# 3. aplicar modulo ambiental: univariado y multivariado
spx_amb <- do.environmental.label(env = envars, data_base = spx, col_lon = "lon", col_lat = "lat",
univar = T, multivar = T)
View(spx_amb)
a <- data.frame(spx$lon, spx$lat)
a <- cbind(spx_geo, spx_amb)
write.csv(a)
write.csv(a, ".csv", row.names = F)
